{"version":3,"file":"index.js","mappings":"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","sources":["webpack://xatlas-three/webpack/bootstrap","webpack://xatlas-three/webpack/runtime/define property getters","webpack://xatlas-three/webpack/runtime/hasOwnProperty shorthand","webpack://xatlas-three/./src/UVUnwrapper.ts","webpack://xatlas-three/./src/baseXAtlas.ts","webpack://xatlas-three/./node_modules/comlink/dist/esm/comlink.mjs","webpack://xatlas-three/./src/XAtlasWebWorker.ts","webpack://xatlas-three/./src/unwrapperWorker.ts"],"sourcesContent":["// The require scope\nvar __webpack_require__ = {};\n\n","// define getter functions for harmony exports\n__webpack_require__.d = (exports, definition) => {\n\tfor(var key in definition) {\n\t\tif(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {\n\t\t\tObject.defineProperty(exports, key, { enumerable: true, get: definition[key] });\n\t\t}\n\t}\n};","__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))","import type {BufferGeometry, BufferAttribute, TypedArray} from \"three\";\r\nimport type {XAtlasWebWorker} from \"./XAtlasWebWorker\";\r\nimport type {XAtlasJS} from \"./XAtlasJS\";\r\nimport type {BaseXAtlas} from \"./baseXAtlas\";\r\n\r\nexport type Class<T> = new (...args: any[]) => T\r\n\r\nexport interface ChartOptions {\r\n    maxIterations?: number,\r\n    straightnessWeight?: number,\r\n    textureSeamWeight?: number,\r\n    useInputMeshUvs?: boolean,\r\n    maxChartArea?: number,\r\n    normalDeviationWeight?: number,\r\n    maxCost?: number,\r\n    roundnessWeight?: number,\r\n    maxBoundaryLength?: number,\r\n    normalSeamWeight?: number,\r\n    fixWinding?: boolean\r\n}\r\n\r\nexport interface PackOptions {\r\n    maxChartSize?: number,\r\n    padding?: number,\r\n    bilinear?: boolean,\r\n    createImage?: boolean,\r\n    rotateCharts?: boolean,\r\n    rotateChartsToAxis?: boolean,\r\n    blockAlign?: boolean,\r\n    resolution?: number,\r\n    bruteForce?: boolean,\r\n    texelsPerUnit?: number\r\n}\r\n\r\nexport interface Atlas {\r\n    width: number,\r\n    height: number,\r\n    atlasCount: number,\r\n    // chartCount: number,\r\n    meshCount: number,\r\n    texelsPerUnit: number,\r\n    geometries: (BufferGeometry & {\r\n        userData: BufferGeometry['userData'] & {\r\n            xAtlasSubMeshes?: { index: number, count: number, atlasIndex: number }[]\r\n        }\r\n    })[],\r\n    meshes: {\r\n        mesh: string, // uuid\r\n        vertex: {\r\n            vertices: number[],\r\n            normals?: number[],\r\n            coords?: number[],\r\n            coords1?: number[],\r\n        },\r\n        index?: number[],\r\n        oldIndexes: number[],\r\n        subMeshes?: { index: number, count: number, atlasIndex: number }[]\r\n    }[]\r\n}\r\n\r\n/**\r\n * Base class for unwrapping three.js geometries using xatlas. Check the usage guide at https://github.com/repalash/xatlas-three\r\n * @license\r\n * Copyright 2022 repalash\r\n * SPDX-License-Identifier: MIT\r\n */\r\nexport abstract class BaseUVUnwrapper {\r\n    protected xAtlas: XAtlasWebWorker | XAtlasJS | BaseXAtlas;\r\n\r\n    /**\r\n     *\r\n     * @param THREE - for reference to BufferAttribute\r\n     * @param packOptions - options for packing\r\n     * @param chartOptions - options for unwrapping\r\n     * @param useNormals - If true, will use the normals to calculate the uv\r\n     * @param timeUnwrap - Logs the time taken to unwrap geometries\r\n     * @param logProgress - Logs the unwrapping progress\r\n     */\r\n    constructor(\r\n        public THREE: { BufferAttribute: Class<BufferAttribute> },\r\n        public packOptions: PackOptions = {\r\n            resolution: 2048,\r\n        },\r\n        public chartOptions: ChartOptions = {},\r\n        public useNormals: boolean = false,\r\n        public timeUnwrap: boolean = false,\r\n        public logProgress: boolean = false,\r\n    ) {\r\n        this.xAtlas = this._createXAtlas()\r\n    }\r\n\r\n    private _libraryLoaded = false;\r\n\r\n    async loadLibrary(onProgress: (mode: any, progress: any) => void, wasmFilePath: string, workerFilePath?: string): Promise<void> {\r\n        if (this._libraryLoaded) return\r\n        await new Promise<void>((resolve, reject) => {\r\n            try {\r\n                this.xAtlas.init(resolve, onProgress, wasmFilePath, workerFilePath)\r\n            } catch (e) {\r\n                reject(e)\r\n            }\r\n        })\r\n        while (!(this.xAtlas.api ? await this.xAtlas.api.loaded : false)) {\r\n            await new Promise(r => setTimeout(r, 100)); // wait for load just in case\r\n        }\r\n        this._libraryLoaded = true;\r\n    }\r\n\r\n    private _isUnwrapping = false;\r\n\r\n    /**\r\n     * Pack multiple geometry into a single atlas\r\n     * Writes to the uv2 attribute of the geometry by default. Use outputUv to specify the attribute to write to\r\n     * Note that the node/meshes are three.js Geometries, not three.js Meshes/Object3D\r\n     * @param nodeList - list of geometries to unwrap\r\n     * @param outputUv - Attribute to write the output uv to\r\n     * @param inputUv - Attribute to write the input uv to (if any)\r\n     */\r\n    public async packAtlas(nodeList: BufferGeometry[], outputUv: 'uv' | 'uv2' = 'uv2', inputUv: 'uv' | 'uv2' = 'uv'): Promise<Atlas> {\r\n        if (!this._libraryLoaded) {\r\n            throw new Error('xatlas-three: library not loaded');\r\n        }\r\n        if (!nodeList) throw new Error('xatlas-three: nodeList argument not provided');\r\n        if (nodeList.length < 1) throw new Error('xatlas-three: nodeList must have non-zero length');\r\n        const useUvs = this.chartOptions.useInputMeshUvs;\r\n\r\n        while (this._isUnwrapping) {\r\n            console.log(\"xatlas-three: unwrapping another mesh, waiting 100 ms\");\r\n            await new Promise(r => setTimeout(r, 100));\r\n        }\r\n        // if(!(xAtlas.loaded)) { // when not using worker. todo\r\n        // xAtlas.addOnLoad(proxy(()=>xAtlasUnWrapLiteGLMeshes(nodeList, onFinish, chartOptions, packOptions, useNormals, useUvs, resultAttribute, originalAttribute)));\r\n        // return;\r\n        // }\r\n        this._isUnwrapping = true;\r\n\r\n        await this.xAtlas.api.setProgressLogging(this.logProgress);\r\n        await this.xAtlas.api.createAtlas();\r\n        let meshAdded = [];\r\n        let tag = \"\"; // for time logging\r\n        for (let mesh of nodeList) {\r\n            let {uuid, index, attributes} = mesh;\r\n            const scaled = mesh.userData.worldScale || 1; // can be [number, number, number] or number\r\n\r\n            // if (unwrap === false) continue;\r\n\r\n            meshAdded.push(uuid);\r\n            if (!index || !attributes.position || attributes.position!.itemSize !== 3) {\r\n                console.warn(\"xatlas-three: Geometry not supported: \", mesh)\r\n                continue;\r\n            }\r\n            tag = \"Mesh\" + meshAdded.length + \" added to atlas: \" + uuid;\r\n            // console.log(typeof index.array)\r\n            if (this.timeUnwrap) console.time(tag);\r\n            await this.xAtlas.api.addMesh(index.array, (attributes.position as BufferAttribute).array, attributes.normal ? (attributes.normal as BufferAttribute).array : undefined, attributes.uv ? (attributes.uv as BufferAttribute).array : undefined, uuid, this.useNormals, useUvs, scaled);\r\n            if (this.timeUnwrap) console.timeEnd(tag);\r\n        }\r\n        tag = \"Generated atlas with \" + meshAdded.length + \" meshes\";\r\n        if (this.timeUnwrap) console.time(tag);\r\n        const atlas = await this.xAtlas.api.generateAtlas(this.chartOptions, this.packOptions, true);\r\n        if (this.timeUnwrap) console.timeEnd(tag);\r\n\r\n        let geometries = [];\r\n\r\n        for (let m of atlas.meshes) {\r\n            let mesh = nodeList.find(n => n.uuid === m.mesh)\r\n            if (!mesh) {\r\n                console.error(\"xatlas-three: Geometry not found: \", m.mesh)\r\n                continue;\r\n            }\r\n            // if(mesh.getAttribute(\"position\"))\r\n            //     mesh.deleteAttribute(\"position\");\r\n            // if(mesh.getAttribute(\"normal\") && m.vertex.normal)\r\n            //     mesh.deleteAttribute(\"normal\");\r\n            // if(mesh.getAttribute(\"uv\") && m.vertex.uv)\r\n            //     mesh.deleteAttribute(\"uv\");\r\n            // if(mesh.getAttribute(\"uv2\"))\r\n            //     mesh.deleteAttribute(\"uv2\");\r\n            // if(mesh.getIndex())\r\n            //     mesh.setIndex(null);\r\n\r\n            if (m.vertex.vertices) mesh.setAttribute('position', new this.THREE.BufferAttribute(m.vertex.vertices, 3, false));\r\n            if (m.vertex.normals) mesh.setAttribute('normal', new this.THREE.BufferAttribute(m.vertex.normals, 3, true));\r\n            if (m.vertex.coords1) mesh.setAttribute(outputUv, new this.THREE.BufferAttribute(m.vertex.coords1, 2, false));\r\n            if (m.vertex.coords && outputUv !== inputUv) mesh.setAttribute(inputUv, new this.THREE.BufferAttribute(m.vertex.coords, 2, false));\r\n            if (m.index) mesh.setIndex(new this.THREE.BufferAttribute(m.index, 1, false));\r\n            if (m.subMeshes) mesh.userData.xAtlasSubMeshes = structuredClone(m.subMeshes);\r\n            // console.log(mesh)\r\n\r\n            // convert any remaining buffer attributes\r\n            const oldIndexes = m.oldIndexes;\r\n            const attributes = mesh.attributes;\r\n            for (const key in attributes) {\r\n                // skip any attributes that have already been set.\r\n                if (\r\n                    key === 'position' ||\r\n                    key === 'normal' ||\r\n                    key === outputUv ||\r\n                    key === inputUv\r\n                ) {\r\n                    continue;\r\n                }\r\n\r\n                // old attribute info\r\n                const oldAttribute = attributes[ key ] as BufferAttribute;\r\n                const bufferCons = oldAttribute.array.constructor as Class<TypedArray>;\r\n                const itemSize = oldAttribute.itemSize;\r\n                const oldArray = oldAttribute.array;\r\n\r\n                // create a new attribute\r\n                const newArray = new bufferCons(oldIndexes.length * itemSize);\r\n                const newAttribute = new this.THREE.BufferAttribute(newArray, itemSize, oldAttribute.normalized);\r\n                newAttribute.gpuType = oldAttribute.gpuType;\r\n\r\n                // copy the data\r\n                for ( let i = 0, l = oldIndexes.length; i < l; i ++ ) {\r\n                    const index = oldIndexes[ i ];\r\n                    for ( let c = 0; c < itemSize; c ++ ) {\r\n                        newArray[ i * itemSize + c ] = oldArray[ index * itemSize + c ];\r\n                    }\r\n                }\r\n\r\n                mesh.setAttribute(key, newAttribute);\r\n            }\r\n\r\n            geometries.push(mesh);\r\n        }\r\n\r\n        await this.xAtlas.api.destroyAtlas();\r\n        this._isUnwrapping = false;\r\n\r\n        return {\r\n            width: atlas.width,\r\n            height: atlas.height,\r\n            atlasCount: atlas.atlasCount,\r\n            // chartCount: atlas.chartCount,\r\n            meshCount: atlas.meshCount,\r\n            texelsPerUnit: atlas.texelsPerUnit,\r\n            geometries,\r\n            meshes: atlas.meshes,\r\n        };\r\n    }\r\n\r\n    /**\r\n     * Unwraps a geometry to generate uv\r\n     * Writes to the uv attribute of the geometry by default. Use outputUv to specify the attribute to write to\r\n     * @param geometry\r\n     * @param outputUv\r\n     * @param inputUv\r\n     */\r\n    public async unwrapGeometry(geometry: BufferGeometry, outputUv: 'uv' | 'uv2' = 'uv', inputUv: 'uv' | 'uv2' = 'uv2') {\r\n        return this.packAtlas([geometry], outputUv, inputUv);\r\n    }\r\n\r\n    protected abstract _createXAtlas(): any;\r\n\r\n}\r\n","export abstract class BaseXAtlas {\n    api: any\n\n    abstract init(onLoad: () => void, onProgress: (mode: any, progress: any) => void, wasmFilePath: string, workerFilePath?: string): void\n}\n","/**\n * @license\n * Copyright 2019 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */\nconst proxyMarker = Symbol(\"Comlink.proxy\");\nconst createEndpoint = Symbol(\"Comlink.endpoint\");\nconst releaseProxy = Symbol(\"Comlink.releaseProxy\");\nconst finalizer = Symbol(\"Comlink.finalizer\");\nconst throwMarker = Symbol(\"Comlink.thrown\");\nconst isObject = (val) => (typeof val === \"object\" && val !== null) || typeof val === \"function\";\n/**\n * Internal transfer handle to handle objects marked to proxy.\n */\nconst proxyTransferHandler = {\n    canHandle: (val) => isObject(val) && val[proxyMarker],\n    serialize(obj) {\n        const { port1, port2 } = new MessageChannel();\n        expose(obj, port1);\n        return [port2, [port2]];\n    },\n    deserialize(port) {\n        port.start();\n        return wrap(port);\n    },\n};\n/**\n * Internal transfer handler to handle thrown exceptions.\n */\nconst throwTransferHandler = {\n    canHandle: (value) => isObject(value) && throwMarker in value,\n    serialize({ value }) {\n        let serialized;\n        if (value instanceof Error) {\n            serialized = {\n                isError: true,\n                value: {\n                    message: value.message,\n                    name: value.name,\n                    stack: value.stack,\n                },\n            };\n        }\n        else {\n            serialized = { isError: false, value };\n        }\n        return [serialized, []];\n    },\n    deserialize(serialized) {\n        if (serialized.isError) {\n            throw Object.assign(new Error(serialized.value.message), serialized.value);\n        }\n        throw serialized.value;\n    },\n};\n/**\n * Allows customizing the serialization of certain values.\n */\nconst transferHandlers = new Map([\n    [\"proxy\", proxyTransferHandler],\n    [\"throw\", throwTransferHandler],\n]);\nfunction isAllowedOrigin(allowedOrigins, origin) {\n    for (const allowedOrigin of allowedOrigins) {\n        if (origin === allowedOrigin || allowedOrigin === \"*\") {\n            return true;\n        }\n        if (allowedOrigin instanceof RegExp && allowedOrigin.test(origin)) {\n            return true;\n        }\n    }\n    return false;\n}\nfunction expose(obj, ep = globalThis, allowedOrigins = [\"*\"]) {\n    ep.addEventListener(\"message\", function callback(ev) {\n        if (!ev || !ev.data) {\n            return;\n        }\n        if (!isAllowedOrigin(allowedOrigins, ev.origin)) {\n            console.warn(`Invalid origin '${ev.origin}' for comlink proxy`);\n            return;\n        }\n        const { id, type, path } = Object.assign({ path: [] }, ev.data);\n        const argumentList = (ev.data.argumentList || []).map(fromWireValue);\n        let returnValue;\n        try {\n            const parent = path.slice(0, -1).reduce((obj, prop) => obj[prop], obj);\n            const rawValue = path.reduce((obj, prop) => obj[prop], obj);\n            switch (type) {\n                case \"GET\" /* MessageType.GET */:\n                    {\n                        returnValue = rawValue;\n                    }\n                    break;\n                case \"SET\" /* MessageType.SET */:\n                    {\n                        parent[path.slice(-1)[0]] = fromWireValue(ev.data.value);\n                        returnValue = true;\n                    }\n                    break;\n                case \"APPLY\" /* MessageType.APPLY */:\n                    {\n                        returnValue = rawValue.apply(parent, argumentList);\n                    }\n                    break;\n                case \"CONSTRUCT\" /* MessageType.CONSTRUCT */:\n                    {\n                        const value = new rawValue(...argumentList);\n                        returnValue = proxy(value);\n                    }\n                    break;\n                case \"ENDPOINT\" /* MessageType.ENDPOINT */:\n                    {\n                        const { port1, port2 } = new MessageChannel();\n                        expose(obj, port2);\n                        returnValue = transfer(port1, [port1]);\n                    }\n                    break;\n                case \"RELEASE\" /* MessageType.RELEASE */:\n                    {\n                        returnValue = undefined;\n                    }\n                    break;\n                default:\n                    return;\n            }\n        }\n        catch (value) {\n            returnValue = { value, [throwMarker]: 0 };\n        }\n        Promise.resolve(returnValue)\n            .catch((value) => {\n            return { value, [throwMarker]: 0 };\n        })\n            .then((returnValue) => {\n            const [wireValue, transferables] = toWireValue(returnValue);\n            ep.postMessage(Object.assign(Object.assign({}, wireValue), { id }), transferables);\n            if (type === \"RELEASE\" /* MessageType.RELEASE */) {\n                // detach and deactive after sending release response above.\n                ep.removeEventListener(\"message\", callback);\n                closeEndPoint(ep);\n                if (finalizer in obj && typeof obj[finalizer] === \"function\") {\n                    obj[finalizer]();\n                }\n            }\n        })\n            .catch((error) => {\n            // Send Serialization Error To Caller\n            const [wireValue, transferables] = toWireValue({\n                value: new TypeError(\"Unserializable return value\"),\n                [throwMarker]: 0,\n            });\n            ep.postMessage(Object.assign(Object.assign({}, wireValue), { id }), transferables);\n        });\n    });\n    if (ep.start) {\n        ep.start();\n    }\n}\nfunction isMessagePort(endpoint) {\n    return endpoint.constructor.name === \"MessagePort\";\n}\nfunction closeEndPoint(endpoint) {\n    if (isMessagePort(endpoint))\n        endpoint.close();\n}\nfunction wrap(ep, target) {\n    return createProxy(ep, [], target);\n}\nfunction throwIfProxyReleased(isReleased) {\n    if (isReleased) {\n        throw new Error(\"Proxy has been released and is not useable\");\n    }\n}\nfunction releaseEndpoint(ep) {\n    return requestResponseMessage(ep, {\n        type: \"RELEASE\" /* MessageType.RELEASE */,\n    }).then(() => {\n        closeEndPoint(ep);\n    });\n}\nconst proxyCounter = new WeakMap();\nconst proxyFinalizers = \"FinalizationRegistry\" in globalThis &&\n    new FinalizationRegistry((ep) => {\n        const newCount = (proxyCounter.get(ep) || 0) - 1;\n        proxyCounter.set(ep, newCount);\n        if (newCount === 0) {\n            releaseEndpoint(ep);\n        }\n    });\nfunction registerProxy(proxy, ep) {\n    const newCount = (proxyCounter.get(ep) || 0) + 1;\n    proxyCounter.set(ep, newCount);\n    if (proxyFinalizers) {\n        proxyFinalizers.register(proxy, ep, proxy);\n    }\n}\nfunction unregisterProxy(proxy) {\n    if (proxyFinalizers) {\n        proxyFinalizers.unregister(proxy);\n    }\n}\nfunction createProxy(ep, path = [], target = function () { }) {\n    let isProxyReleased = false;\n    const proxy = new Proxy(target, {\n        get(_target, prop) {\n            throwIfProxyReleased(isProxyReleased);\n            if (prop === releaseProxy) {\n                return () => {\n                    unregisterProxy(proxy);\n                    releaseEndpoint(ep);\n                    isProxyReleased = true;\n                };\n            }\n            if (prop === \"then\") {\n                if (path.length === 0) {\n                    return { then: () => proxy };\n                }\n                const r = requestResponseMessage(ep, {\n                    type: \"GET\" /* MessageType.GET */,\n                    path: path.map((p) => p.toString()),\n                }).then(fromWireValue);\n                return r.then.bind(r);\n            }\n            return createProxy(ep, [...path, prop]);\n        },\n        set(_target, prop, rawValue) {\n            throwIfProxyReleased(isProxyReleased);\n            // FIXME: ES6 Proxy Handler `set` methods are supposed to return a\n            // boolean. To show good will, we return true asynchronously ¯\\_(ツ)_/¯\n            const [value, transferables] = toWireValue(rawValue);\n            return requestResponseMessage(ep, {\n                type: \"SET\" /* MessageType.SET */,\n                path: [...path, prop].map((p) => p.toString()),\n                value,\n            }, transferables).then(fromWireValue);\n        },\n        apply(_target, _thisArg, rawArgumentList) {\n            throwIfProxyReleased(isProxyReleased);\n            const last = path[path.length - 1];\n            if (last === createEndpoint) {\n                return requestResponseMessage(ep, {\n                    type: \"ENDPOINT\" /* MessageType.ENDPOINT */,\n                }).then(fromWireValue);\n            }\n            // We just pretend that `bind()` didn’t happen.\n            if (last === \"bind\") {\n                return createProxy(ep, path.slice(0, -1));\n            }\n            const [argumentList, transferables] = processArguments(rawArgumentList);\n            return requestResponseMessage(ep, {\n                type: \"APPLY\" /* MessageType.APPLY */,\n                path: path.map((p) => p.toString()),\n                argumentList,\n            }, transferables).then(fromWireValue);\n        },\n        construct(_target, rawArgumentList) {\n            throwIfProxyReleased(isProxyReleased);\n            const [argumentList, transferables] = processArguments(rawArgumentList);\n            return requestResponseMessage(ep, {\n                type: \"CONSTRUCT\" /* MessageType.CONSTRUCT */,\n                path: path.map((p) => p.toString()),\n                argumentList,\n            }, transferables).then(fromWireValue);\n        },\n    });\n    registerProxy(proxy, ep);\n    return proxy;\n}\nfunction myFlat(arr) {\n    return Array.prototype.concat.apply([], arr);\n}\nfunction processArguments(argumentList) {\n    const processed = argumentList.map(toWireValue);\n    return [processed.map((v) => v[0]), myFlat(processed.map((v) => v[1]))];\n}\nconst transferCache = new WeakMap();\nfunction transfer(obj, transfers) {\n    transferCache.set(obj, transfers);\n    return obj;\n}\nfunction proxy(obj) {\n    return Object.assign(obj, { [proxyMarker]: true });\n}\nfunction windowEndpoint(w, context = globalThis, targetOrigin = \"*\") {\n    return {\n        postMessage: (msg, transferables) => w.postMessage(msg, targetOrigin, transferables),\n        addEventListener: context.addEventListener.bind(context),\n        removeEventListener: context.removeEventListener.bind(context),\n    };\n}\nfunction toWireValue(value) {\n    for (const [name, handler] of transferHandlers) {\n        if (handler.canHandle(value)) {\n            const [serializedValue, transferables] = handler.serialize(value);\n            return [\n                {\n                    type: \"HANDLER\" /* WireValueType.HANDLER */,\n                    name,\n                    value: serializedValue,\n                },\n                transferables,\n            ];\n        }\n    }\n    return [\n        {\n            type: \"RAW\" /* WireValueType.RAW */,\n            value,\n        },\n        transferCache.get(value) || [],\n    ];\n}\nfunction fromWireValue(value) {\n    switch (value.type) {\n        case \"HANDLER\" /* WireValueType.HANDLER */:\n            return transferHandlers.get(value.name).deserialize(value.value);\n        case \"RAW\" /* WireValueType.RAW */:\n            return value.value;\n    }\n}\nfunction requestResponseMessage(ep, msg, transfers) {\n    return new Promise((resolve) => {\n        const id = generateUUID();\n        ep.addEventListener(\"message\", function l(ev) {\n            if (!ev.data || !ev.data.id || ev.data.id !== id) {\n                return;\n            }\n            ep.removeEventListener(\"message\", l);\n            resolve(ev.data);\n        });\n        if (ep.start) {\n            ep.start();\n        }\n        ep.postMessage(Object.assign({ id }, msg), transfers);\n    });\n}\nfunction generateUUID() {\n    return new Array(4)\n        .fill(0)\n        .map(() => Math.floor(Math.random() * Number.MAX_SAFE_INTEGER).toString(16))\n        .join(\"-\");\n}\n\nexport { createEndpoint, expose, finalizer, proxy, proxyMarker, releaseProxy, transfer, transferHandlers, windowEndpoint, wrap };\n//# sourceMappingURL=comlink.mjs.map\n","import {BaseXAtlas} from \"./baseXAtlas\";\nimport {proxy, wrap} from \"comlink\";\n\nexport class XAtlasWebWorker extends BaseXAtlas {\n\n    init(onLoad: () => void, onProgress: (mode: any, progress: any) => void, wasmFilePath: string, workerFilePath?: string): void {\n        if (this.api) return\n        if(!workerFilePath) throw new Error(\"workerFilePath is required\");\n        (async () => {\n            const workerCode = await fetch(workerFilePath).then(res => res.blob());\n            const workerUrl = URL.createObjectURL(workerCode);\n            const t = new Worker(workerUrl, {type: 'module', });\n            // @ts-ignore\n            this.api = await (new (wrap(t))(\n                    proxy(()=>{\n                        onLoad();\n                        URL.revokeObjectURL(workerUrl);\n                    }),\n                    proxy((path: string, dir: string) => {\n                        return (path === \"xatlas.wasm\" ? wasmFilePath : path + dir)\n                    }),\n                    proxy(onProgress))\n            )\n        })()\n    }\n\n}\n","import {BaseUVUnwrapper} from \"./UVUnwrapper\";\nimport {XAtlasWebWorker} from \"./XAtlasWebWorker\";\n\nexport class UVUnwrapper extends BaseUVUnwrapper{\n    protected _createXAtlas(): any {\n        return new XAtlasWebWorker()\n    }\n}\n"],"names":["__webpack_require__","exports","definition","key","o","Object","defineProperty","enumerable","get","obj","prop","prototype","hasOwnProperty","call","BaseUVUnwrapper","constructor","THREE","packOptions","resolution","chartOptions","useNormals","timeUnwrap","logProgress","_libraryLoaded","_isUnwrapping","this","xAtlas","_createXAtlas","loadLibrary","onProgress","wasmFilePath","workerFilePath","Promise","resolve","reject","init","e","api","loaded","r","setTimeout","packAtlas","nodeList","outputUv","inputUv","Error","length","useUvs","useInputMeshUvs","console","log","setProgressLogging","createAtlas","meshAdded","tag","mesh","uuid","index","attributes","scaled","userData","worldScale","push","position","itemSize","time","addMesh","array","normal","undefined","uv","timeEnd","warn","atlas","generateAtlas","geometries","m","meshes","find","n","error","vertex","vertices","setAttribute","BufferAttribute","normals","coords1","coords","setIndex","subMeshes","xAtlasSubMeshes","structuredClone","oldIndexes","oldAttribute","bufferCons","oldArray","newArray","newAttribute","normalized","gpuType","i","l","c","destroyAtlas","width","height","atlasCount","meshCount","texelsPerUnit","unwrapGeometry","geometry","BaseXAtlas","proxyMarker","Symbol","createEndpoint","releaseProxy","finalizer","throwMarker","isObject","val","transferHandlers","Map","canHandle","serialize","port1","port2","MessageChannel","expose","deserialize","port","start","wrap","value","serialized","isError","message","name","stack","assign","ep","globalThis","allowedOrigins","addEventListener","callback","ev","data","origin","allowedOrigin","RegExp","test","isAllowedOrigin","id","type","path","argumentList","map","fromWireValue","returnValue","parent","slice","reduce","rawValue","apply","proxy","transfers","transferCache","set","transfer","catch","then","wireValue","transferables","toWireValue","postMessage","removeEventListener","closeEndPoint","TypeError","endpoint","isMessagePort","close","target","createProxy","throwIfProxyReleased","isReleased","releaseEndpoint","requestResponseMessage","proxyCounter","WeakMap","proxyFinalizers","FinalizationRegistry","newCount","isProxyReleased","Proxy","_target","unregister","unregisterProxy","p","toString","bind","_thisArg","rawArgumentList","last","processArguments","construct","register","registerProxy","processed","v","arr","Array","concat","handler","serializedValue","msg","fill","Math","floor","random","Number","MAX_SAFE_INTEGER","join","XAtlasWebWorker","onLoad","workerCode","fetch","res","blob","workerUrl","URL","createObjectURL","t","Worker","revokeObjectURL","dir","UVUnwrapper"],"sourceRoot":""}